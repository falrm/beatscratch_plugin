// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/protobeats/music.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NoteName corresponds to "white keys" (notes A-G)
enum NoteLetter: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case c // = 0
  case d // = 1
  case e // = 2
  case f // = 3
  case g // = 4
  case a // = 5
  case b // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .c
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .c
    case 1: self = .d
    case 2: self = .e
    case 3: self = .f
    case 4: self = .g
    case 5: self = .a
    case 6: self = .b
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .c: return 0
    case .d: return 1
    case .e: return 2
    case .f: return 3
    case .g: return 4
    case .a: return 5
    case .b: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NoteLetter: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [NoteLetter] = [
    .c,
    .d,
    .e,
    .f,
    .g,
    .a,
    .b,
  ]
}

#endif  // swift(>=4.2)

enum NoteSign: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case natural // = 0
  case flat // = 1
  case doubleFlat // = 2
  case sharp // = 3
  case doubleSharp // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .natural
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .natural
    case 1: self = .flat
    case 2: self = .doubleFlat
    case 3: self = .sharp
    case 4: self = .doubleSharp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .natural: return 0
    case .flat: return 1
    case .doubleFlat: return 2
    case .sharp: return 3
    case .doubleSharp: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NoteSign: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [NoteSign] = [
    .natural,
    .flat,
    .doubleFlat,
    .sharp,
    .doubleSharp,
  ]
}

#endif  // swift(>=4.2)

enum InstrumentType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Represents actual tones, with a basis of "tones" of C4 = 0.
  case harmonic // = 0

  /// Represents MIDI drum tones (so B1, below C2, is a kick, F#2 is a hat, etc.) from C4 = 0
  case drum // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .harmonic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .harmonic
    case 1: self = .drum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .harmonic: return 0
    case .drum: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InstrumentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [InstrumentType] = [
    .harmonic,
    .drum,
  ]
}

#endif  // swift(>=4.2)

enum MelodyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Uses MidiChanges and represents raw MIDI instrument data.
  case midi // = 0

  /// TODO: In a future version, we will envelope audio bytes in the proto models.
  /// No corresponding message types go with this yet.
  case audio // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .midi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .midi
    case 1: self = .audio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .midi: return 0
    case .audio: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MelodyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MelodyType] = [
    .midi,
    .audio,
  ]
}

#endif  // swift(>=4.2)

/// Indicates how a Melody should be interpreted when referenced in a Section under a Harmony.
enum MelodyInterpretationType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Notes of the Melody should be played as-is
  case fixedNonadaptive // = 0

  /// Notes of the Melody should be played, adjusting to the nearest tone in the Chord,
  /// favoring a move down over a move up when two tones in the Chord are above/below the indicated
  /// tone.
  case fixed // = 1

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of C.
  case relativeToC // = 2

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of C#.
  case relativeToCSharp // = 3

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of D.
  case relativeToD // = 4

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of D#.
  case relativeToDSharp // = 5

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of E.
  case relativeToE // = 6

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of F.
  case relativeToF // = 7

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of F#.
  case relativeToFSharp // = 8

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of G.
  case relativeToG // = 9

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of G#.
  case relativeToGSharp // = 10

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of A.
  case relativeToA // = 11

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of A#.
  case relativeToASharp // = 12

  /// Notes of the Melody should be played, adapting to the chord as in the case of "fixed", but
  /// should also transpose up/down to the Chord's root. Melody is built assuming a root of B.
  case relativeToB // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .fixedNonadaptive
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fixedNonadaptive
    case 1: self = .fixed
    case 2: self = .relativeToC
    case 3: self = .relativeToCSharp
    case 4: self = .relativeToD
    case 5: self = .relativeToDSharp
    case 6: self = .relativeToE
    case 7: self = .relativeToF
    case 8: self = .relativeToFSharp
    case 9: self = .relativeToG
    case 10: self = .relativeToGSharp
    case 11: self = .relativeToA
    case 12: self = .relativeToASharp
    case 13: self = .relativeToB
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .fixedNonadaptive: return 0
    case .fixed: return 1
    case .relativeToC: return 2
    case .relativeToCSharp: return 3
    case .relativeToD: return 4
    case .relativeToDSharp: return 5
    case .relativeToE: return 6
    case .relativeToF: return 7
    case .relativeToFSharp: return 8
    case .relativeToG: return 9
    case .relativeToGSharp: return 10
    case .relativeToA: return 11
    case .relativeToASharp: return 12
    case .relativeToB: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MelodyInterpretationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MelodyInterpretationType] = [
    .fixedNonadaptive,
    .fixed,
    .relativeToC,
    .relativeToCSharp,
    .relativeToD,
    .relativeToDSharp,
    .relativeToE,
    .relativeToF,
    .relativeToFSharp,
    .relativeToG,
    .relativeToGSharp,
    .relativeToA,
    .relativeToASharp,
    .relativeToB,
  ]
}

#endif  // swift(>=4.2)

/// Describes notes as pitch classes (i.e. without octave)
struct NoteName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var noteLetter: NoteLetter = .c

  var noteSign: NoteSign = .natural

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Chord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rootNote: NoteName {
    get {return _rootNote ?? NoteName()}
    set {_rootNote = newValue}
  }
  /// Returns true if `rootNote` has been explicitly set.
  var hasRootNote: Bool {return self._rootNote != nil}
  /// Clears the value of `rootNote`. Subsequent reads from it will return its default value.
  mutating func clearRootNote() {self._rootNote = nil}

  /// Optional. When note provided, applications referencing bass_note should generally
  /// be able to revert to root_note.
  var bassNote: NoteName {
    get {return _bassNote ?? NoteName()}
    set {_bassNote = newValue}
  }
  /// Returns true if `bassNote` has been explicitly set.
  var hasBassNote: Bool {return self._bassNote != nil}
  /// Clears the value of `bassNote`. Subsequent reads from it will return its default value.
  mutating func clearBassNote() {self._bassNote = nil}

  /// 11-bit bit-set value from 0-2047. Bits (in order from msb to lsb) indicate presence of the
  /// minor 2, major 2, minor 3, major 3, ..., major 7 of the chord. Some examples:
  /// * 0 = 0b00000000000 is a chord of just the root note with no other notes.
  /// * 144 = 0b00010010000 is a regular Major chord.
  /// * 145 = 0b00010010001 is a Major 7 (M7) chord.
  /// * A neat math thing: every odd extension has a M7 in it. Every even one does not.
  /// * 2047 = 0b11111111111 is a chromatic scale rooted at root_note.
  /// * 725 = 0b01011010101 is a major scale or a M13(11) chord (which are the same thing).
  ///
  /// With music theory, the idea is that we can derive the Note (i.e., differentiate whether these
  /// should be a C# or Db) for all the tones in the extension based on the root_note and bass_note.
  var chroma: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rootNote: NoteName? = nil
  fileprivate var _bassNote: NoteName? = nil
}

struct Tempo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bpm: Float = 0

  var transition: Tempo.Transition = .aTempo

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Transition: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Indicates the Section should be played at the same tempo throughout. If the next Section
    /// has a different bpm, the change will be sudden with no gradual speed up/slow down.
    case aTempo // = 0

    /// Indicates the Section should start at the indicated bpm, and linearly increase or
    /// decrease bpm to match the bpm of the next Section
    case linear // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .aTempo
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .aTempo
      case 1: self = .linear
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .aTempo: return 0
      case .linear: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tempo.Transition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tempo.Transition] = [
    .aTempo,
    .linear,
  ]
}

#endif  // swift(>=4.2)

struct Meter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var defaultBeatsPerMeasure: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Harmony is a rhythmic mapping of chords.
struct Harmony {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var subdivisionsPerBeat: UInt32 = 0

  /// Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  var length: UInt32 = 0

  /// Must contain at least one entry with key less than Harmony length. Generally, should contain
  /// an entry at 0.
  var data: Dictionary<Int32,Chord> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Melody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for a Melody. Should be kept unique within a given Score.
  var id: String = String()

  /// Optional name for the Melody.
  var name: String = String()

  /// How many subdivisions per beat the melody is in. Allowed values are 1-24 (MIDI beat clock max).
  /// 1 per beat is quarter notes in 4/4 time; 3 is triplet eighths; 4 is sixteenths; 6 is triplet
  /// sixteenths; etc.
  var subdivisionsPerBeat: UInt32 = 0

  /// Length in subdivisions (so, length in beats is length / subdivisions_per_beat)
  var length: UInt32 = 0

  /// Indicates what type of data (attacks only or full MIDI) this melody uses.
  var type: MelodyType = .midi

  /// Indicates what type of instrument the Melody is for. In the context of a Score,
  /// should match the Part's instrument type. Useful for letting the user copy/paste Melodies
  /// between Parts.
  var instrumentType: InstrumentType = .harmonic

  var interpretationType: MelodyInterpretationType = .fixedNonadaptive

  /// The Melody notes/data, the type of which should match the MelodyType.
  var data: Melody.OneOf_Data? = nil

  var midiData: MidiData {
    get {
      if case .midiData(let v)? = data {return v}
      return MidiData()
    }
    set {data = .midiData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The Melody notes/data, the type of which should match the MelodyType.
  enum OneOf_Data: Equatable {
    case midiData(MidiData)

  #if !swift(>=4.1)
    static func ==(lhs: Melody.OneOf_Data, rhs: Melody.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.midiData, .midiData): return {
        guard case .midiData(let l) = lhs, case .midiData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// Map of subdivisions to MIDI data.
struct MidiData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Dictionary<Int32,MidiChange> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A "classical" notion of a slice of a melody defined to be easy to analyze, draw on a screen
/// and make touchable. A "rest" is any MelodicAttack with no tones. MelodicAttacks can represent a
/// traditional "music theory class" single-note melody, but expanded slightly so that we can have
/// multiple notes. Notes must all attack at once and release at once.
///
/// To phrase it more simply, this way of breaking down melodies forces you to separate your
/// soprano from your bass part. Unless they're singing the exact same rhythm the entire time.
struct MelodicAttack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tones: [Int32] = []

  /// Valid range: 0 to 1.
  var velocity: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents raw midi data (corresponding to a subidivision in a melody). Can include NOTE ON,
/// NOTE OFF, knobby things, etc. Playback engine is responsible for modifying channel from original
/// recorded MIDI messages at playback time. Note that MIDI note names are a first-class citizen:
/// *in a MidiChange NOTE ON or NOTE OFF, C4 = 60. Elsewhere C4 = 0.
///
/// To phrase it more simply, this way of breaking down melodies will let you represent your soprano
/// and bass parts as a single "melody." But your music theory teach would berate you in class for
/// that. These are also harder to make editable by touch, but handy for recording MIDI performance
/// by a musician.
struct MidiChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Instrument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var type: InstrumentType = .harmonic

  var volume: Float = 0

  var midiChannel: UInt32 = 0

  var midiInstrument: UInt32 = 0

  var midiGm2Msb: UInt32 = 0

  var midiGm2Lsb: UInt32 = 0

  /// This list of SoundFont names and KeySwitch labels is to be compared against
  /// what the user has available in
  var soundFonts: SoundFonts {
    get {return _soundFonts ?? SoundFonts()}
    set {_soundFonts = newValue}
  }
  /// Returns true if `soundFonts` has been explicitly set.
  var hasSoundFonts: Bool {return self._soundFonts != nil}
  /// Clears the value of `soundFonts`. Subsequent reads from it will return its default value.
  mutating func clearSoundFonts() {self._soundFonts = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _soundFonts: SoundFonts? = nil
}

/// A SoundFonts message can represent one of two things:
/// 1) A prioritized list of preferred SoundFonts/KeySwitches to be used for a Part
/// 2) A list of all SoundFonts and KeySwitches available on the system.
/// The platform audio system is responsible for picking the appropriate SoundFonts
/// for a Part based on these names and labels. So when users load SoundFonts, they should
/// ideally not mess with names of them. (Labels are hardcoded in the SFZ files and less
/// likely to be messed with.)
struct SoundFonts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var soundFonts: [SoundFont] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SoundFont {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var keySwitches: [KeySwitch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KeySwitch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Part {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var instrument: Instrument {
    get {return _instrument ?? Instrument()}
    set {_instrument = newValue}
  }
  /// Returns true if `instrument` has been explicitly set.
  var hasInstrument: Bool {return self._instrument != nil}
  /// Clears the value of `instrument`. Subsequent reads from it will return its default value.
  mutating func clearInstrument() {self._instrument = nil}

  var melodies: [Melody] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _instrument: Instrument? = nil
}

struct MelodyReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var melodyID: String = String()

  var playbackType: MelodyReference.PlaybackType = .disabled

  /// Volume, between 0 and 1.
  var volume: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PlaybackType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled // = 0
    case playbackIndefinitely // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .playbackIndefinitely
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .playbackIndefinitely: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension MelodyReference.PlaybackType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [MelodyReference.PlaybackType] = [
    .disabled,
    .playbackIndefinitely,
  ]
}

#endif  // swift(>=4.2)

struct Section {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var harmony: Harmony {
    get {return _harmony ?? Harmony()}
    set {_harmony = newValue}
  }
  /// Returns true if `harmony` has been explicitly set.
  var hasHarmony: Bool {return self._harmony != nil}
  /// Clears the value of `harmony`. Subsequent reads from it will return its default value.
  mutating func clearHarmony() {self._harmony = nil}

  var meter: Meter {
    get {return _meter ?? Meter()}
    set {_meter = newValue}
  }
  /// Returns true if `meter` has been explicitly set.
  var hasMeter: Bool {return self._meter != nil}
  /// Clears the value of `meter`. Subsequent reads from it will return its default value.
  mutating func clearMeter() {self._meter = nil}

  var tempo: Tempo {
    get {return _tempo ?? Tempo()}
    set {_tempo = newValue}
  }
  /// Returns true if `tempo` has been explicitly set.
  var hasTempo: Bool {return self._tempo != nil}
  /// Clears the value of `tempo`. Subsequent reads from it will return its default value.
  mutating func clearTempo() {self._tempo = nil}

  var key: NoteName {
    get {return _key ?? NoteName()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var melodies: [MelodyReference] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Color: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case major // = 0
    case minor // = 1
    case dominant // = 2
    case augmented // = 3
    case diminished // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .major
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .major
      case 1: self = .minor
      case 2: self = .dominant
      case 3: self = .augmented
      case 4: self = .diminished
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .major: return 0
      case .minor: return 1
      case .dominant: return 2
      case .augmented: return 3
      case .diminished: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _harmony: Harmony? = nil
  fileprivate var _meter: Meter? = nil
  fileprivate var _tempo: Tempo? = nil
  fileprivate var _key: NoteName? = nil
}

#if swift(>=4.2)

extension Section.Color: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Section.Color] = [
    .major,
    .minor,
    .dominant,
    .augmented,
    .diminished,
  ]
}

#endif  // swift(>=4.2)

struct Score {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var parts: [Part] = []

  var sections: [Section] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension NoteLetter: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "C"),
    1: .same(proto: "D"),
    2: .same(proto: "E"),
    3: .same(proto: "F"),
    4: .same(proto: "G"),
    5: .same(proto: "A"),
    6: .same(proto: "B"),
  ]
}

extension NoteSign: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "natural"),
    1: .same(proto: "flat"),
    2: .same(proto: "double_flat"),
    3: .same(proto: "sharp"),
    4: .same(proto: "double_sharp"),
  ]
}

extension InstrumentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "harmonic"),
    1: .same(proto: "drum"),
  ]
}

extension MelodyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "midi"),
    1: .same(proto: "audio"),
  ]
}

extension MelodyInterpretationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "fixed_nonadaptive"),
    1: .same(proto: "fixed"),
    2: .same(proto: "relative_to_c"),
    3: .same(proto: "relative_to_c_sharp"),
    4: .same(proto: "relative_to_d"),
    5: .same(proto: "relative_to_d_sharp"),
    6: .same(proto: "relative_to_e"),
    7: .same(proto: "relative_to_f"),
    8: .same(proto: "relative_to_f_sharp"),
    9: .same(proto: "relative_to_g"),
    10: .same(proto: "relative_to_g_sharp"),
    11: .same(proto: "relative_to_a"),
    12: .same(proto: "relative_to_a_sharp"),
    13: .same(proto: "relative_to_b"),
  ]
}

extension NoteName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NoteName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_letter"),
    2: .standard(proto: "note_sign"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.noteLetter) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.noteSign) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.noteLetter != .c {
      try visitor.visitSingularEnumField(value: self.noteLetter, fieldNumber: 1)
    }
    if self.noteSign != .natural {
      try visitor.visitSingularEnumField(value: self.noteSign, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NoteName, rhs: NoteName) -> Bool {
    if lhs.noteLetter != rhs.noteLetter {return false}
    if lhs.noteSign != rhs.noteSign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Chord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_note"),
    2: .standard(proto: "bass_note"),
    3: .same(proto: "chroma"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rootNote) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bassNote) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chroma) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rootNote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._bassNote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.chroma != 0 {
      try visitor.visitSingularUInt32Field(value: self.chroma, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Chord, rhs: Chord) -> Bool {
    if lhs._rootNote != rhs._rootNote {return false}
    if lhs._bassNote != rhs._bassNote {return false}
    if lhs.chroma != rhs.chroma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tempo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Tempo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bpm"),
    2: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.bpm) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bpm != 0 {
      try visitor.visitSingularFloatField(value: self.bpm, fieldNumber: 1)
    }
    if self.transition != .aTempo {
      try visitor.visitSingularEnumField(value: self.transition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tempo, rhs: Tempo) -> Bool {
    if lhs.bpm != rhs.bpm {return false}
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tempo.Transition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "a_tempo"),
    1: .same(proto: "linear"),
  ]
}

extension Meter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Meter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_beats_per_measure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.defaultBeatsPerMeasure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.defaultBeatsPerMeasure != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultBeatsPerMeasure, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Meter, rhs: Meter) -> Bool {
    if lhs.defaultBeatsPerMeasure != rhs.defaultBeatsPerMeasure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Harmony: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Harmony"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "subdivisions_per_beat"),
    3: .same(proto: "length"),
    100: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.subdivisionsPerBeat) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,Chord>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.subdivisionsPerBeat != 0 {
      try visitor.visitSingularUInt32Field(value: self.subdivisionsPerBeat, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,Chord>.self, value: self.data, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Harmony, rhs: Harmony) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subdivisionsPerBeat != rhs.subdivisionsPerBeat {return false}
    if lhs.length != rhs.length {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Melody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Melody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "subdivisions_per_beat"),
    4: .same(proto: "length"),
    5: .same(proto: "type"),
    6: .standard(proto: "instrument_type"),
    7: .standard(proto: "interpretation_type"),
    101: .standard(proto: "midi_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.subdivisionsPerBeat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.instrumentType) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.interpretationType) }()
      case 101: try {
        var v: MidiData?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .midiData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .midiData(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.subdivisionsPerBeat != 0 {
      try visitor.visitSingularUInt32Field(value: self.subdivisionsPerBeat, fieldNumber: 3)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 4)
    }
    if self.type != .midi {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if self.instrumentType != .harmonic {
      try visitor.visitSingularEnumField(value: self.instrumentType, fieldNumber: 6)
    }
    if self.interpretationType != .fixedNonadaptive {
      try visitor.visitSingularEnumField(value: self.interpretationType, fieldNumber: 7)
    }
    if case .midiData(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Melody, rhs: Melody) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.subdivisionsPerBeat != rhs.subdivisionsPerBeat {return false}
    if lhs.length != rhs.length {return false}
    if lhs.type != rhs.type {return false}
    if lhs.instrumentType != rhs.instrumentType {return false}
    if lhs.interpretationType != rhs.interpretationType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MidiData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MidiData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MidiChange>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufSInt32,MidiChange>.self, value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MidiData, rhs: MidiData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MelodicAttack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MelodicAttack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tones"),
    2: .same(proto: "velocity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSInt32Field(value: &self.tones) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.velocity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tones.isEmpty {
      try visitor.visitPackedSInt32Field(value: self.tones, fieldNumber: 1)
    }
    if self.velocity != 0 {
      try visitor.visitSingularFloatField(value: self.velocity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MelodicAttack, rhs: MelodicAttack) -> Bool {
    if lhs.tones != rhs.tones {return false}
    if lhs.velocity != rhs.velocity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MidiChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MidiChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MidiChange, rhs: MidiChange) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Instrument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Instrument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "volume"),
    4: .standard(proto: "midi_channel"),
    5: .standard(proto: "midi_instrument"),
    6: .standard(proto: "midi_gm2_msb"),
    7: .standard(proto: "midi_gm2_lsb"),
    8: .standard(proto: "sound_fonts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.volume) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.midiChannel) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.midiInstrument) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.midiGm2Msb) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.midiGm2Lsb) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._soundFonts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .harmonic {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.volume != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 3)
    }
    if self.midiChannel != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiChannel, fieldNumber: 4)
    }
    if self.midiInstrument != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiInstrument, fieldNumber: 5)
    }
    if self.midiGm2Msb != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiGm2Msb, fieldNumber: 6)
    }
    if self.midiGm2Lsb != 0 {
      try visitor.visitSingularUInt32Field(value: self.midiGm2Lsb, fieldNumber: 7)
    }
    if let v = self._soundFonts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Instrument, rhs: Instrument) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.midiChannel != rhs.midiChannel {return false}
    if lhs.midiInstrument != rhs.midiInstrument {return false}
    if lhs.midiGm2Msb != rhs.midiGm2Msb {return false}
    if lhs.midiGm2Lsb != rhs.midiGm2Lsb {return false}
    if lhs._soundFonts != rhs._soundFonts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoundFonts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SoundFonts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sound_fonts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.soundFonts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.soundFonts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.soundFonts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SoundFonts, rhs: SoundFonts) -> Bool {
    if lhs.soundFonts != rhs.soundFonts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SoundFont: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SoundFont"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "key_switches"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keySwitches) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.keySwitches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keySwitches, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SoundFont, rhs: SoundFont) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.keySwitches != rhs.keySwitches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeySwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeySwitch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeySwitch, rhs: KeySwitch) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Part: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Part"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "instrument"),
    4: .same(proto: "melodies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._instrument) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.melodies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if let v = self._instrument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.melodies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.melodies, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Part, rhs: Part) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._instrument != rhs._instrument {return false}
    if lhs.melodies != rhs.melodies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MelodyReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MelodyReference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "melody_id"),
    2: .standard(proto: "playback_type"),
    3: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.melodyID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.playbackType) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.melodyID.isEmpty {
      try visitor.visitSingularStringField(value: self.melodyID, fieldNumber: 1)
    }
    if self.playbackType != .disabled {
      try visitor.visitSingularEnumField(value: self.playbackType, fieldNumber: 2)
    }
    if self.volume != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MelodyReference, rhs: MelodyReference) -> Bool {
    if lhs.melodyID != rhs.melodyID {return false}
    if lhs.playbackType != rhs.playbackType {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MelodyReference.PlaybackType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "disabled"),
    1: .same(proto: "playback_indefinitely"),
  ]
}

extension Section: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Section"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "harmony"),
    4: .same(proto: "meter"),
    5: .same(proto: "tempo"),
    6: .same(proto: "key"),
    100: .same(proto: "melodies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._harmony) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._meter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tempo) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 100: try { try decoder.decodeRepeatedMessageField(value: &self.melodies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._harmony {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._meter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._tempo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.melodies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.melodies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Section, rhs: Section) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._harmony != rhs._harmony {return false}
    if lhs._meter != rhs._meter {return false}
    if lhs._tempo != rhs._tempo {return false}
    if lhs._key != rhs._key {return false}
    if lhs.melodies != rhs.melodies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Section.Color: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "major"),
    1: .same(proto: "minor"),
    2: .same(proto: "dominant"),
    3: .same(proto: "augmented"),
    4: .same(proto: "diminished"),
  ]
}

extension Score: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Score"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "parts"),
    4: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.parts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parts, fieldNumber: 3)
    }
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Score, rhs: Score) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.parts != rhs.parts {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
